/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2025-02-08 03:36:05.686486
/// Generated using solver translation3d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12;
x0=IKcos(j[0]);
x1=IKsin(j[1]);
x2=IKcos(j[1]);
x3=IKcos(j[2]);
x4=IKsin(j[2]);
x5=IKsin(j[0]);
x6=((0.002)*x3);
x7=((0.236815132767373)*x1);
x8=((0.2802)*x4);
x9=((0.2802)*x3);
x10=(x2*x5);
x11=(x0*x2);
x12=((0.002)*x1*x4);
eetrans[0]=((0.01)+((x0*x7))+(((-1.0)*x0*x12))+(((0.0300024)*x11))+((x11*x6))+((x11*x8))+((x0*x1*x9)));
eetrans[1]=(((x1*x5*x9))+(((-1.0)*x12*x5))+((x5*x7))+(((0.0300024)*x10))+((x10*x8))+((x10*x6)));
IkReal x13=((1.0)*x1);
eetrans[2]=((0.123059270394975)+(((-1.0)*x13*x6))+(((-1.0)*x13*x8))+(((-0.0300024)*x1))+((x2*x9))+(((0.236815132767373)*x2))+(((-0.002)*x2*x4)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 3; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=((-0.01)+px);
new_py=py;
new_pz=((-0.123059270394975)+pz);
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
if( (((-1.01287359929203)+(((7.47521480617637)*(px*px)))+(((7.47521480617637)*(pz*pz)))+(((7.47521480617637)*(py*py))))) < -1-IKFAST_SINCOS_THRESH || (((-1.01287359929203)+(((7.47521480617637)*(px*px)))+(((7.47521480617637)*(pz*pz)))+(((7.47521480617637)*(py*py))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x14=IKasin(((-1.01287359929203)+(((7.47521480617637)*(px*px)))+(((7.47521480617637)*(pz*pz)))+(((7.47521480617637)*(py*py)))));
j2array[0]=((-1.45191410866581)+(((1.0)*x14)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((1.68967854492398)+(((-1.0)*x14)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[1];
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
j1eval[0]=((3.59140601883394)+sj2+(((8.37202213298632)*cj2))+(((4.94867151071202)*(sj2*sj2)))+(((4.94867151071202)*(cj2*cj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
j1eval[1]=((3.59140601883394)+sj2+(((8.37202213298632)*cj2))+(((4.94867151071202)*(sj2*sj2)))+(((4.94867151071202)*(cj2*cj2))));
j1eval[2]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
j1eval[1]=(((cj2*pz))+(((15.0012)*pz))+(((140.1)*pz*sj2)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x15=pz*pz;
IkReal x16=IKabs(pz);
IkReal x17=x15;
CheckValue<IkReal> x23=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*x16)),-1);
if(!x23.valid){
continue;
}
IkReal x18=x23.value;
IkReal x24 = x17;
if(IKabs(x24)==0){
continue;
}
IkReal x19=pow(x24,-0.5);
CheckValue<IkReal> x25=IKPowWithIntegerCheck(x16,-2);
if(!x25.valid){
continue;
}
if((((1.0)+(((-0.0114644600741454)*x15*(x25.value))))) < -0.00001)
continue;
IkReal x20=IKsqrt(((1.0)+(((-0.0114644600741454)*x15*(x25.value)))));
IkReal x21=(x15*x18*x19);
IkReal x22=(pz*x19*x20);
if((x17) < -0.00001)
continue;
CheckValue<IkReal> x26=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(x17)))),-1);
if(!x26.valid){
continue;
}
if( (((150.012)*pz*(x26.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x26.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x27 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x27.valid){
continue;
}
IkReal gconst0=((((-1.0)*(IKasin(((150.012)*pz*(x26.value))))))+(((-1.0)*(x27.value))));
IkReal gconst1=((((-150.008178770334)*x21))+(((-0.00713757692486359)*x22)));
IkReal gconst2=((((0.999974527173388)*x22))+(((-1.07072218965264)*x21)));
if((pz*pz) < -0.00001)
continue;
CheckValue<IkReal> x28=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(pz*pz)))),-1);
if(!x28.valid){
continue;
}
if( (((150.012)*pz*(x28.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x28.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x29 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x29.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(((150.012)*pz*(x28.value))))+(x29.value)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[2];
IkReal x30=pz*pz;
IkReal x31=IKabs(pz);
IkReal x32=x30;
IkReal x33=x18;
IkReal x39 = x32;
if(IKabs(x39)==0){
continue;
}
IkReal x34=pow(x39,-0.5);
IkReal x35=x20;
IkReal x36=(x30*x33*x34);
if((x32) < -0.00001)
continue;
CheckValue<IkReal> x40=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(x32)))),-1);
if(!x40.valid){
continue;
}
if( (((150.012)*pz*(x40.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x40.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x41 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x41.valid){
continue;
}
IkReal x37=((((-1.0)*(IKasin(((150.012)*pz*(x40.value))))))+(((-1.0)*(x41.value))));
IkReal x38=(pz*x34*x35);
px=0;
py=0;
pp=x30;
sj2=gconst1;
cj2=gconst2;
j2=x37;
IkReal gconst0=x37;
IkReal gconst1=((((-150.008178770334)*x36))+(((-0.00713757692486359)*x38)));
IkReal gconst2=((((-1.07072218965264)*x36))+(((0.999974527173388)*x38)));
j1eval[0]=pz;
j1eval[1]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x42=pz*pz;
IkReal x43=IKabs(pz);
IkReal x44=x42;
IkReal x45=x18;
IkReal x51 = x44;
if(IKabs(x51)==0){
continue;
}
IkReal x46=pow(x51,-0.5);
IkReal x47=x20;
IkReal x48=(x42*x45*x46);
CheckValue<IkReal> x52 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x52.valid){
continue;
}
if((x44) < -0.00001)
continue;
CheckValue<IkReal> x53=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(x44)))),-1);
if(!x53.valid){
continue;
}
if( (((150.012)*pz*(x53.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x53.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x49=((((-1.0)*(x52.value)))+(((-1.0)*(IKasin(((150.012)*pz*(x53.value)))))));
IkReal x50=(pz*x46*x47);
px=0;
py=0;
pp=x42;
sj2=gconst1;
cj2=gconst2;
j2=x49;
IkReal gconst0=x49;
IkReal gconst1=((((-150.008178770334)*x48))+(((-0.00713757692486359)*x50)));
IkReal gconst2=((((0.999974527173388)*x50))+(((-1.07072218965264)*x48)));
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x54=pz*pz;
IkReal x55=IKabs(pz);
IkReal x56=x54;
IkReal x57=x18;
IkReal x63 = x56;
if(IKabs(x63)==0){
continue;
}
IkReal x58=pow(x63,-0.5);
IkReal x59=x20;
IkReal x60=(x54*x57*x58);
if((x56) < -0.00001)
continue;
CheckValue<IkReal> x64=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(x56)))),-1);
if(!x64.valid){
continue;
}
if( (((150.012)*pz*(x64.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x64.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x65 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x65.valid){
continue;
}
IkReal x61=((((-1.0)*(IKasin(((150.012)*pz*(x64.value))))))+(((-1.0)*(x65.value))));
IkReal x62=(pz*x58*x59);
px=0;
py=0;
pp=x54;
sj2=gconst1;
cj2=gconst2;
j2=x61;
IkReal gconst0=x61;
IkReal gconst1=((((-150.008178770334)*x60))+(((-0.00713757692486359)*x62)));
IkReal gconst2=((((0.999974527173388)*x62))+(((-1.07072218965264)*x60)));
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x66=IKPowWithIntegerCheck(pz,-1);
if(!x66.valid){
continue;
}
CheckValue<IkReal> x67=IKPowWithIntegerCheck(((((0.002)*gconst1*pz))+(((-0.236815132767373)*pz))+(((-0.2802)*gconst2*pz))),-1);
if(!x67.valid){
continue;
}
if( IKabs(((x66.value)*(((-0.0300024)+(((-0.002)*gconst2))+(((-0.2802)*gconst1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x67.value)*(((0.00090014400576)+(((0.07851204)*(gconst1*gconst1)))+(((0.0001200096)*gconst2))+(((4.0e-6)*(gconst2*gconst2)))+(((-1.0)*(pz*pz)))+(((0.01681334496)*gconst1))+(((0.0011208)*gconst1*gconst2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x66.value)*(((-0.0300024)+(((-0.002)*gconst2))+(((-0.2802)*gconst1))))))+IKsqr(((x67.value)*(((0.00090014400576)+(((0.07851204)*(gconst1*gconst1)))+(((0.0001200096)*gconst2))+(((4.0e-6)*(gconst2*gconst2)))+(((-1.0)*(pz*pz)))+(((0.01681334496)*gconst1))+(((0.0011208)*gconst1*gconst2))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x66.value)*(((-0.0300024)+(((-0.002)*gconst2))+(((-0.2802)*gconst1))))), ((x67.value)*(((0.00090014400576)+(((0.07851204)*(gconst1*gconst1)))+(((0.0001200096)*gconst2))+(((4.0e-6)*(gconst2*gconst2)))+(((-1.0)*(pz*pz)))+(((0.01681334496)*gconst1))+(((0.0011208)*gconst1*gconst2))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x68=IKcos(j1);
IkReal x69=IKsin(j1);
IkReal x70=((0.002)*gconst1);
IkReal x71=((0.2802)*gconst1);
IkReal x72=((0.002)*gconst2);
IkReal x73=((0.2802)*gconst2);
IkReal x74=(pz*x68);
IkReal x75=(pz*x69);
evalcond[0]=((0.0300024)+x75+x72+x71);
evalcond[1]=((0.236815132767373)+(((-1.0)*x70))+x73+(((-1.0)*x74)));
evalcond[2]=((0.0215344888866115)+(((-0.0600048)*x75))+(((-1.0)*(pz*pz)))+(((0.473630265534746)*x74)));
evalcond[3]=((((0.0300024)*x68))+((x69*x73))+((x68*x71))+((x68*x72))+(((-1.0)*x69*x70))+(((0.236815132767373)*x69)));
evalcond[4]=((((0.0300024)*x69))+((x69*x72))+((x69*x71))+(((-0.236815132767373)*x68))+((x68*x70))+pz+(((-1.0)*x68*x73)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x77=IKPowWithIntegerCheck(pz,-1);
if(!x77.valid){
continue;
}
IkReal x76=x77.value;
CheckValue<IkReal> x78=IKPowWithIntegerCheck(x76,-2);
if(!x78.valid){
continue;
}
if( IKabs((x76*(((-0.0300024)+(((-0.002)*gconst2))+(((-0.2802)*gconst1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((6.4e-14)*x76*(((-769811212595.655)+(((-554670032970.533)*gconst1))+(((-3959100877.734)*gconst2))+(((32989868125000.0)*(x78.value))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x76*(((-0.0300024)+(((-0.002)*gconst2))+(((-0.2802)*gconst1))))))+IKsqr(((6.4e-14)*x76*(((-769811212595.655)+(((-554670032970.533)*gconst1))+(((-3959100877.734)*gconst2))+(((32989868125000.0)*(x78.value)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x76*(((-0.0300024)+(((-0.002)*gconst2))+(((-0.2802)*gconst1))))), ((6.4e-14)*x76*(((-769811212595.655)+(((-554670032970.533)*gconst1))+(((-3959100877.734)*gconst2))+(((32989868125000.0)*(x78.value)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x79=IKcos(j1);
IkReal x80=IKsin(j1);
IkReal x81=((0.002)*gconst1);
IkReal x82=((0.2802)*gconst1);
IkReal x83=((0.002)*gconst2);
IkReal x84=((0.2802)*gconst2);
IkReal x85=(pz*x79);
IkReal x86=(pz*x80);
evalcond[0]=((0.0300024)+x82+x83+x86);
evalcond[1]=((0.236815132767373)+x84+(((-1.0)*x85))+(((-1.0)*x81)));
evalcond[2]=((0.0215344888866115)+(((0.473630265534746)*x85))+(((-1.0)*(pz*pz)))+(((-0.0600048)*x86)));
evalcond[3]=(((x79*x82))+((x79*x83))+(((-1.0)*x80*x81))+(((0.0300024)*x79))+(((0.236815132767373)*x80))+((x80*x84)));
evalcond[4]=((((0.0300024)*x80))+((x79*x81))+(((-0.236815132767373)*x79))+(((-1.0)*x79*x84))+pz+((x80*x82))+((x80*x83)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x87 = IKatan2WithCheck(IkReal(((-0.0300024)+(((-0.002)*gconst2))+(((-0.2802)*gconst1)))),IkReal(((0.236815132767373)+(((-0.002)*gconst1))+(((0.2802)*gconst2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x87.valid){
continue;
}
CheckValue<IkReal> x88=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x88.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x87.value)+(((1.5707963267949)*(x88.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x89=IKcos(j1);
IkReal x90=IKsin(j1);
IkReal x91=((0.002)*gconst1);
IkReal x92=((0.2802)*gconst1);
IkReal x93=((0.002)*gconst2);
IkReal x94=((0.2802)*gconst2);
IkReal x95=(pz*x89);
IkReal x96=(pz*x90);
evalcond[0]=((0.0300024)+x93+x92+x96);
evalcond[1]=((0.236815132767373)+x94+(((-1.0)*x95))+(((-1.0)*x91)));
evalcond[2]=((0.0215344888866115)+(((0.473630265534746)*x95))+(((-1.0)*(pz*pz)))+(((-0.0600048)*x96)));
evalcond[3]=((((0.0300024)*x89))+((x89*x92))+((x89*x93))+(((-1.0)*x90*x91))+((x90*x94))+(((0.236815132767373)*x90)));
evalcond[4]=((((0.0300024)*x90))+((x89*x91))+(((-0.236815132767373)*x89))+((x90*x93))+((x90*x92))+pz+(((-1.0)*x89*x94)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x97=pz*pz;
IkReal x98=IKabs(pz);
IkReal x99=x97;
CheckValue<IkReal> x105=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*x98)),-1);
if(!x105.valid){
continue;
}
IkReal x100=x105.value;
IkReal x106 = x99;
if(IKabs(x106)==0){
continue;
}
IkReal x101=pow(x106,-0.5);
CheckValue<IkReal> x107=IKPowWithIntegerCheck(x98,-2);
if(!x107.valid){
continue;
}
if((((1.0)+(((-0.0114644600741454)*x97*(x107.value))))) < -0.00001)
continue;
IkReal x102=IKsqrt(((1.0)+(((-0.0114644600741454)*x97*(x107.value)))));
IkReal x103=(x100*x101*x97);
IkReal x104=(pz*x101*x102);
if((x99) < -0.00001)
continue;
CheckValue<IkReal> x108=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(x99)))),-1);
if(!x108.valid){
continue;
}
if( (((150.012)*pz*(x108.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x108.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x109 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x109.valid){
continue;
}
IkReal gconst3=((3.14159265358979)+(IKasin(((150.012)*pz*(x108.value))))+(((-1.0)*(x109.value))));
IkReal gconst4=((((-150.008178770334)*x103))+(((0.00713757692486359)*x104)));
IkReal gconst5=((((-1.07072218965264)*x103))+(((-0.999974527173388)*x104)));
CheckValue<IkReal> x110 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x110.valid){
continue;
}
if((pz*pz) < -0.00001)
continue;
CheckValue<IkReal> x111=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(pz*pz)))),-1);
if(!x111.valid){
continue;
}
if( (((150.012)*pz*(x111.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x111.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x110.value)+(((-1.0)*(IKasin(((150.012)*pz*(x111.value))))))+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[2];
IkReal x112=pz*pz;
IkReal x113=IKabs(pz);
IkReal x114=x112;
CheckValue<IkReal> x122 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x122.valid){
continue;
}
IkReal x115=((1.0)*(x122.value));
IkReal x116=x100;
IkReal x123 = x114;
if(IKabs(x123)==0){
continue;
}
IkReal x117=pow(x123,-0.5);
IkReal x118=x102;
if((x114) < -0.00001)
continue;
CheckValue<IkReal> x124=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(x114)))),-1);
if(!x124.valid){
continue;
}
if( (((150.012)*pz*(x124.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x124.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x119=IKasin(((150.012)*pz*(x124.value)));
IkReal x120=(x112*x116*x117);
IkReal x121=(pz*x117*x118);
px=0;
py=0;
pp=x112;
sj2=gconst4;
cj2=gconst5;
j2=((3.14159265)+(((-1.0)*x115))+x119);
IkReal gconst3=((3.14159265358979)+(((-1.0)*x115))+x119);
IkReal gconst4=((((-150.008178770334)*x120))+(((0.00713757692486359)*x121)));
IkReal gconst5=((((-0.999974527173388)*x121))+(((-1.07072218965264)*x120)));
j1eval[0]=pz;
j1eval[1]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x125=pz*pz;
IkReal x126=IKabs(pz);
IkReal x127=x125;
CheckValue<IkReal> x135 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x135.valid){
continue;
}
IkReal x128=((1.0)*(x135.value));
IkReal x129=x100;
IkReal x136 = x127;
if(IKabs(x136)==0){
continue;
}
IkReal x130=pow(x136,-0.5);
IkReal x131=x102;
if((x127) < -0.00001)
continue;
CheckValue<IkReal> x137=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(x127)))),-1);
if(!x137.valid){
continue;
}
if( (((150.012)*pz*(x137.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x137.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x132=IKasin(((150.012)*pz*(x137.value)));
IkReal x133=(x125*x129*x130);
IkReal x134=(pz*x130*x131);
px=0;
py=0;
pp=x125;
sj2=gconst4;
cj2=gconst5;
j2=((3.14159265)+(((-1.0)*x128))+x132);
IkReal gconst3=((3.14159265358979)+(((-1.0)*x128))+x132);
IkReal gconst4=((((-150.008178770334)*x133))+(((0.00713757692486359)*x134)));
IkReal gconst5=((((-0.999974527173388)*x134))+(((-1.07072218965264)*x133)));
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x138=pz*pz;
IkReal x139=IKabs(pz);
IkReal x140=x138;
CheckValue<IkReal> x148 = IKatan2WithCheck(IkReal(pz),IkReal(((140.1)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x148.valid){
continue;
}
IkReal x141=((1.0)*(x148.value));
IkReal x142=x100;
IkReal x149 = x140;
if(IKabs(x149)==0){
continue;
}
IkReal x143=pow(x149,-0.5);
IkReal x144=x102;
if((x140) < -0.00001)
continue;
CheckValue<IkReal> x150=IKPowWithIntegerCheck(IKabs(((1401.03568833917)*(IKsqrt(x140)))),-1);
if(!x150.valid){
continue;
}
if( (((150.012)*pz*(x150.value))) < -1-IKFAST_SINCOS_THRESH || (((150.012)*pz*(x150.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x145=IKasin(((150.012)*pz*(x150.value)));
IkReal x146=(x138*x142*x143);
IkReal x147=(pz*x143*x144);
px=0;
py=0;
pp=x138;
sj2=gconst4;
cj2=gconst5;
j2=((3.14159265)+(((-1.0)*x141))+x145);
IkReal gconst3=((3.14159265358979)+(((-1.0)*x141))+x145);
IkReal gconst4=((((-150.008178770334)*x146))+(((0.00713757692486359)*x147)));
IkReal gconst5=((((-0.999974527173388)*x147))+(((-1.07072218965264)*x146)));
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x151=((0.2802)*gconst4);
IkReal x152=((0.002)*gconst5);
CheckValue<IkReal> x153=IKPowWithIntegerCheck(pz,-1);
if(!x153.valid){
continue;
}
CheckValue<IkReal> x154=IKPowWithIntegerCheck(((((0.0300024)*pz))+((pz*x151))+((pz*x152))),-1);
if(!x154.valid){
continue;
}
if( IKabs(((x153.value)*(((-0.0300024)+(((-1.0)*x151))+(((-1.0)*x152)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x154.value)*(((0.00710502233933983)+(((0.0005604)*(gconst5*gconst5)))+(((-0.0005604)*(gconst4*gconst4)))+(((0.07850804)*gconst4*gconst5))+(((0.00888030274553475)*gconst5))+(((0.0662955954014179)*gconst4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x153.value)*(((-0.0300024)+(((-1.0)*x151))+(((-1.0)*x152))))))+IKsqr(((x154.value)*(((0.00710502233933983)+(((0.0005604)*(gconst5*gconst5)))+(((-0.0005604)*(gconst4*gconst4)))+(((0.07850804)*gconst4*gconst5))+(((0.00888030274553475)*gconst5))+(((0.0662955954014179)*gconst4))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x153.value)*(((-0.0300024)+(((-1.0)*x151))+(((-1.0)*x152))))), ((x154.value)*(((0.00710502233933983)+(((0.0005604)*(gconst5*gconst5)))+(((-0.0005604)*(gconst4*gconst4)))+(((0.07850804)*gconst4*gconst5))+(((0.00888030274553475)*gconst5))+(((0.0662955954014179)*gconst4))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x155=IKcos(j1);
IkReal x156=IKsin(j1);
IkReal x157=((0.002)*gconst5);
IkReal x158=((0.2802)*gconst4);
IkReal x159=((0.002)*gconst4);
IkReal x160=((0.2802)*gconst5);
IkReal x161=(pz*x156);
IkReal x162=((0.2802)*x155);
IkReal x163=(pz*x155);
evalcond[0]=((0.0300024)+x161+x157+x158);
evalcond[1]=((0.236815132767373)+(((-1.0)*x159))+x160+(((-1.0)*x163)));
evalcond[2]=((0.0215344888866115)+(((0.473630265534746)*x163))+(((-1.0)*(pz*pz)))+(((-0.0600048)*x161)));
evalcond[3]=((((0.0300024)*x155))+((x155*x157))+((x155*x158))+((x156*x160))+(((-1.0)*x156*x159))+(((0.236815132767373)*x156)));
evalcond[4]=((((0.0300024)*x156))+(((-0.236815132767373)*x155))+((x155*x159))+pz+((x156*x158))+((x156*x157))+(((-1.0)*x155*x160)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x165=IKPowWithIntegerCheck(pz,-1);
if(!x165.valid){
continue;
}
IkReal x164=x165.value;
CheckValue<IkReal> x166=IKPowWithIntegerCheck(x164,-2);
if(!x166.valid){
continue;
}
if( IKabs((x164*(((-0.0300024)+(((-0.002)*gconst5))+(((-0.2802)*gconst4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((6.4e-14)*x164*(((-769811212595.655)+(((-554670032970.533)*gconst4))+(((-3959100877.734)*gconst5))+(((32989868125000.0)*(x166.value))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x164*(((-0.0300024)+(((-0.002)*gconst5))+(((-0.2802)*gconst4))))))+IKsqr(((6.4e-14)*x164*(((-769811212595.655)+(((-554670032970.533)*gconst4))+(((-3959100877.734)*gconst5))+(((32989868125000.0)*(x166.value)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x164*(((-0.0300024)+(((-0.002)*gconst5))+(((-0.2802)*gconst4))))), ((6.4e-14)*x164*(((-769811212595.655)+(((-554670032970.533)*gconst4))+(((-3959100877.734)*gconst5))+(((32989868125000.0)*(x166.value)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x167=IKcos(j1);
IkReal x168=IKsin(j1);
IkReal x169=((0.002)*gconst5);
IkReal x170=((0.2802)*gconst4);
IkReal x171=((0.002)*gconst4);
IkReal x172=((0.2802)*gconst5);
IkReal x173=(pz*x168);
IkReal x174=((0.2802)*x167);
IkReal x175=(pz*x167);
evalcond[0]=((0.0300024)+x170+x173+x169);
evalcond[1]=((0.236815132767373)+(((-1.0)*x171))+(((-1.0)*x175))+x172);
evalcond[2]=((0.0215344888866115)+(((0.473630265534746)*x175))+(((-0.0600048)*x173))+(((-1.0)*(pz*pz))));
evalcond[3]=((((0.0300024)*x167))+((x168*x172))+((x167*x170))+((x167*x169))+(((-1.0)*x168*x171))+(((0.236815132767373)*x168)));
evalcond[4]=((((-0.236815132767373)*x167))+(((0.0300024)*x168))+((x168*x170))+((x168*x169))+((x167*x171))+pz+(((-1.0)*x167*x172)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x176=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x176.valid){
continue;
}
CheckValue<IkReal> x177 = IKatan2WithCheck(IkReal(((-0.0300024)+(((-0.002)*gconst5))+(((-0.2802)*gconst4)))),IkReal(((0.236815132767373)+(((-0.002)*gconst4))+(((0.2802)*gconst5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x177.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x176.value)))+(x177.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x178=IKcos(j1);
IkReal x179=IKsin(j1);
IkReal x180=((0.002)*gconst5);
IkReal x181=((0.2802)*gconst4);
IkReal x182=((0.002)*gconst4);
IkReal x183=((0.2802)*gconst5);
IkReal x184=(pz*x179);
IkReal x185=((0.2802)*x178);
IkReal x186=(pz*x178);
evalcond[0]=((0.0300024)+x184+x180+x181);
evalcond[1]=((0.236815132767373)+(((-1.0)*x182))+(((-1.0)*x186))+x183);
evalcond[2]=((0.0215344888866115)+(((0.473630265534746)*x186))+(((-0.0600048)*x184))+(((-1.0)*(pz*pz))));
evalcond[3]=(((x178*x181))+((x178*x180))+(((0.0300024)*x178))+((x179*x183))+(((-1.0)*x179*x182))+(((0.236815132767373)*x179)));
evalcond[4]=((((-1.0)*x178*x183))+((x178*x182))+(((0.0300024)*x179))+((x179*x181))+((x179*x180))+pz+(((-0.236815132767373)*x178)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
j1eval[0]=((1.0)+(((6.00954811644111)*sj2))+(((25.012847301209)*(sj2*sj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x188 = IKatan2WithCheck(IkReal(((0.0490094488890082)+(((0.0354686167271338)*sj2)))),IkReal(((0.0279622530931022)+(((0.279961109088315)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x188.valid){
continue;
}
IkReal x187=x188.value;
j1array[0]=((-1.0)*x187);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x187)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x189=IKcos(j1);
IkReal x190=IKsin(j1);
evalcond[0]=((((-0.0354686167271338)*sj2*x190))+(((0.279961109088315)*sj2*x189))+(((-0.0490094488890082)*x190))+(((0.0279622530931022)*x189)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x191=((0.2802)*sj2);
IkReal x192=((0.002)*cj2);
CheckValue<IkReal> x193=IKPowWithIntegerCheck(pz,-1);
if(!x193.valid){
continue;
}
CheckValue<IkReal> x194=IKPowWithIntegerCheck(((((0.0300024)*pz))+((pz*x191))+((pz*x192))),-1);
if(!x194.valid){
continue;
}
if( IKabs(((x193.value)*(((-0.0300024)+(((-1.0)*x191))+(((-1.0)*x192)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x194.value)*(((0.00654462233933983)+(((0.0662955954014179)*sj2))+(((0.00888030274553475)*cj2))+(((0.07850804)*cj2*sj2))+(((0.0011208)*(cj2*cj2))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x193.value)*(((-0.0300024)+(((-1.0)*x191))+(((-1.0)*x192))))))+IKsqr(((x194.value)*(((0.00654462233933983)+(((0.0662955954014179)*sj2))+(((0.00888030274553475)*cj2))+(((0.07850804)*cj2*sj2))+(((0.0011208)*(cj2*cj2)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x193.value)*(((-0.0300024)+(((-1.0)*x191))+(((-1.0)*x192))))), ((x194.value)*(((0.00654462233933983)+(((0.0662955954014179)*sj2))+(((0.00888030274553475)*cj2))+(((0.07850804)*cj2*sj2))+(((0.0011208)*(cj2*cj2)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x195=IKcos(j1);
IkReal x196=IKsin(j1);
IkReal x197=((0.2802)*sj2);
IkReal x198=((0.002)*sj2);
IkReal x199=((0.2802)*cj2);
IkReal x200=((0.002)*cj2);
IkReal x201=((0.002)*x196);
IkReal x202=(pz*x196);
IkReal x203=(pz*x195);
evalcond[0]=((0.0300024)+x197+x202+x200);
evalcond[1]=((0.236815132767373)+(((-1.0)*x198))+x199+(((-1.0)*x203)));
evalcond[2]=((0.0215344888866115)+(((-0.0600048)*x202))+(((0.473630265534746)*x203))+(((-1.0)*(pz*pz))));
evalcond[3]=((((-1.0)*x196*x198))+(((0.0300024)*x195))+((x195*x200))+((x196*x199))+((x195*x197))+(((0.236815132767373)*x196)));
evalcond[4]=(((x196*x200))+(((-1.0)*x195*x199))+(((0.0300024)*x196))+((x196*x197))+((x195*x198))+pz+(((-0.236815132767373)*x195)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x205=IKPowWithIntegerCheck(pz,-1);
if(!x205.valid){
continue;
}
IkReal x204=x205.value;
CheckValue<IkReal> x206=IKPowWithIntegerCheck(x204,-2);
if(!x206.valid){
continue;
}
if( IKabs((x204*(((-0.0300024)+(((-0.2802)*sj2))+(((-0.002)*cj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((6.4e-14)*x204*(((-769811212595.655)+(((-554670032970.533)*sj2))+(((-3959100877.734)*cj2))+(((32989868125000.0)*(x206.value))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x204*(((-0.0300024)+(((-0.2802)*sj2))+(((-0.002)*cj2))))))+IKsqr(((6.4e-14)*x204*(((-769811212595.655)+(((-554670032970.533)*sj2))+(((-3959100877.734)*cj2))+(((32989868125000.0)*(x206.value)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x204*(((-0.0300024)+(((-0.2802)*sj2))+(((-0.002)*cj2))))), ((6.4e-14)*x204*(((-769811212595.655)+(((-554670032970.533)*sj2))+(((-3959100877.734)*cj2))+(((32989868125000.0)*(x206.value)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x207=IKcos(j1);
IkReal x208=IKsin(j1);
IkReal x209=((0.2802)*sj2);
IkReal x210=((0.002)*sj2);
IkReal x211=((0.2802)*cj2);
IkReal x212=((0.002)*cj2);
IkReal x213=((0.002)*x208);
IkReal x214=(pz*x208);
IkReal x215=(pz*x207);
evalcond[0]=((0.0300024)+x212+x214+x209);
evalcond[1]=((0.236815132767373)+x211+(((-1.0)*x215))+(((-1.0)*x210)));
evalcond[2]=((0.0215344888866115)+(((-0.0600048)*x214))+(((-1.0)*(pz*pz)))+(((0.473630265534746)*x215)));
evalcond[3]=((((0.0300024)*x207))+((x208*x211))+((x207*x212))+(((0.236815132767373)*x208))+(((-1.0)*x208*x210))+((x207*x209)));
evalcond[4]=((((0.0300024)*x208))+((x208*x212))+(((-1.0)*x207*x211))+((x207*x210))+pz+(((-0.236815132767373)*x207))+((x208*x209)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x216 = IKatan2WithCheck(IkReal(((-0.0300024)+(((-0.2802)*sj2))+(((-0.002)*cj2)))),IkReal(((0.236815132767373)+(((0.2802)*cj2))+(((-0.002)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x216.valid){
continue;
}
CheckValue<IkReal> x217=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x217.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x216.value)+(((1.5707963267949)*(x217.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x218=IKcos(j1);
IkReal x219=IKsin(j1);
IkReal x220=((0.2802)*sj2);
IkReal x221=((0.002)*sj2);
IkReal x222=((0.2802)*cj2);
IkReal x223=((0.002)*cj2);
IkReal x224=((0.002)*x219);
IkReal x225=(pz*x219);
IkReal x226=(pz*x218);
evalcond[0]=((0.0300024)+x220+x223+x225);
evalcond[1]=((0.236815132767373)+x222+(((-1.0)*x221))+(((-1.0)*x226)));
evalcond[2]=((0.0215344888866115)+(((-0.0600048)*x225))+(((-1.0)*(pz*pz)))+(((0.473630265534746)*x226)));
evalcond[3]=((((0.236815132767373)*x219))+(((-1.0)*x219*x221))+((x219*x222))+((x218*x220))+((x218*x223))+(((0.0300024)*x218)));
evalcond[4]=((((-0.236815132767373)*x218))+((x219*x220))+((x219*x223))+pz+(((-1.0)*x218*x222))+((x218*x221))+(((0.0300024)*x219)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x227=((-0.236815132767373)+(((0.002)*sj2))+(((-0.2802)*cj2)));
IkReal x228=((0.0300024)+(((0.2802)*sj2))+(((0.002)*cj2)));
CheckValue<IkReal> x231 = IKatan2WithCheck(IkReal(x227),IkReal(x228),IKFAST_ATAN2_MAGTHRESH);
if(!x231.valid){
continue;
}
IkReal x229=((1.0)*(x231.value));
if((((x227*x227)+(x228*x228))) < -0.00001)
continue;
CheckValue<IkReal> x232=IKPowWithIntegerCheck(IKabs(IKsqrt(((x227*x227)+(x228*x228)))),-1);
if(!x232.valid){
continue;
}
if( ((pz*(x232.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x232.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x230=IKasin((pz*(x232.value)));
j1array[0]=((((-1.0)*x230))+(((-1.0)*x229)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x230+(((-1.0)*x229)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[1];
j0eval[0]=((IKabs(px))+(((0.5)*(IKabs(py)))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
{
IkReal j0eval[1];
j0eval[0]=((IKabs((cj1*py)))+(((0.001)*(IKabs(((15.0012)+(((500.0)*cj1*px))+cj2+(((500.0)*pz*sj1))+(((140.1)*sj2))))))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
{
IkReal j0eval[1];
j0eval[0]=((IKabs((py*sj1)))+(((0.001)*(IKabs(((118.407566383686)+(((-1.0)*sj2))+(((-500.0)*cj1*pz))+(((140.1)*cj2))+(((500.0)*px*sj1))))))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x233=((140.1)*cj2);
IkReal x234=((1.0)*sj2);
IkReal x235=((500.0)*cj1*pz);
IkReal x236=((500.0)*px*sj1);
IkReal x237=((118.407566383686)+x233);
IkReal x238=(x234+x235);
op[0]=((((-1.0)*x238))+x236+x237);
op[1]=((-1000.0)*py*sj1);
op[2]=((((-1.0)*x238))+(((-1.0)*x236))+x237);
polyroots2(op,zeror,numroots);
IkReal j0array[2], cj0array[2], sj0array[2], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[2]={true,true};
_nj0 = 2;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x239=((140.1)*sj2);
IkReal x240=((500.0)*pz*sj1);
IkReal x241=((500.0)*cj1*px);
IkReal x242=((15.0012)+cj2+x239+x240);
op[0]=(x242+x241);
op[1]=((-1000.0)*cj1*py);
op[2]=(x242+(((-1.0)*x241)));
polyroots2(op,zeror,numroots);
IkReal j0array[2], cj0array[2], sj0array[2], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[2]={true,true};
_nj0 = 2;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=py;
op[1]=((2.0)*px);
op[2]=((-1.0)*py);
polyroots2(op,zeror,numroots);
IkReal j0array[2], cj0array[2], sj0array[2], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[2]={true,true};
_nj0 = 2;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x244 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x244.valid){
continue;
}
IkReal x243=x244.value;
j0array[0]=((-1.0)*x243);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x243)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[3];
IkReal x245=cj2*cj2;
IkReal x246=(py*sj0);
IkReal x247=((140.1)*sj2);
IkReal x248=(cj0*px);
IkReal x249=((0.2802)*sj2);
IkReal x250=((1.0)*cj2);
IkReal x251=(cj2*sj2);
IkReal x252=(pz*sj2);
IkReal x253=((0.002)*cj2);
IkReal x254=(cj2*pz);
j1eval[0]=((((118.407566383686)*pz))+(((-1.0)*x246*x250))+(((-1.0)*x248*x250))+(((140.1)*x254))+(((-15.0012)*x248))+(((-15.0012)*x246))+(((-1.0)*x246*x247))+(((-1.0)*x247*x248))+(((-1.0)*x252)));
j1eval[1]=((IKabs(((-0.00654462233933983)+(((-0.00888030274553475)*cj2))+(((-0.07850804)*x251))+(((-0.0011208)*x245))+(((-0.0662955954014179)*sj2))+((pz*x246))+((pz*x248)))))+(IKabs(((-0.07941218400576)+(((0.07850804)*x245))+(((-0.0001200096)*cj2))+(((-0.0011208)*x251))+(pz*pz)+(((-0.01681334496)*sj2))))));
j1eval[2]=IKsign(((((-1.0)*x248*x249))+(((0.2802)*x254))+(((-0.0300024)*x246))+(((-0.0300024)*x248))+(((-1.0)*x246*x253))+(((0.236815132767373)*pz))+(((-0.002)*x252))+(((-1.0)*x248*x253))+(((-1.0)*x246*x249))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x255=cj2*cj2;
IkReal x256=(cj0*px);
IkReal x257=((140.1)*cj2);
IkReal x258=(py*sj0);
IkReal x259=((0.002)*sj2);
IkReal x260=(cj2*sj2);
IkReal x261=(pz*sj2);
IkReal x262=((0.2802)*cj2);
IkReal x263=(cj2*pz);
IkReal x264=((1.0)*pz);
j1eval[0]=((((-118.407566383686)*x256))+(((-118.407566383686)*x258))+(((-1.0)*x263))+(((-1.0)*x256*x257))+(((-1.0)*x257*x258))+((sj2*x258))+((sj2*x256))+(((-15.0012)*pz))+(((-140.1)*x261)));
j1eval[1]=((IKabs(((-0.00654462233933983)+(((-0.00888030274553475)*cj2))+(((-1.0)*x258*x264))+(((-0.0011208)*x255))+(((-0.0662955954014179)*sj2))+(((-0.07850804)*x260))+(((-1.0)*x256*x264)))))+(IKabs(((-0.0560854071076285)+(((-0.07850804)*x255))+(pz*pz)+(((0.000947260531069492)*sj2))+(((-0.132711200402836)*cj2))+(((0.0011208)*x260))))));
j1eval[2]=IKsign(((((-1.0)*x258*x262))+(((-0.236815132767373)*x258))+(((-0.236815132767373)*x256))+(((-0.0300024)*pz))+((x256*x259))+(((-0.2802)*x261))+(((-0.002)*x263))+(((-1.0)*x256*x262))+((x258*x259))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=((-8.54007752954596)+(((-1.0)*sj2))+(((-8.37202213298632)*cj2)));
j1eval[1]=IKsign(((-0.135497591113388)+(((-0.132831210002836)*cj2))+(((-0.0158660844289305)*sj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x265=(pz*sj2);
IkReal x266=(cj0*px);
IkReal x267=((0.2802)*cj2);
IkReal x268=((0.002)*cj2);
IkReal x269=((0.2802)*sj2);
IkReal x270=(py*sj0);
IkReal x271=((0.002)*sj2);
IkReal x272=(cj2*x270);
CheckValue<IkReal> x273=IKPowWithIntegerCheck(IKsign(((-0.135497591113388)+(((-0.132831210002836)*cj2))+(((-0.0158660844289305)*sj2)))),-1);
if(!x273.valid){
continue;
}
CheckValue<IkReal> x274 = IKatan2WithCheck(IkReal((((x266*x271))+(((0.0300024)*pz))+(((-0.236815132767373)*x266))+((x270*x271))+(((-0.236815132767373)*x270))+(((0.2802)*x265))+((pz*x268))+(((-1.0)*x266*x267))+(((-1.0)*x267*x270)))),IkReal(((((-0.0300024)*x266))+(((-0.236815132767373)*pz))+(((-1.0)*x269*x270))+(((-0.0300024)*x270))+(((-1.0)*x268*x270))+(((-1.0)*x266*x269))+(((-1.0)*x266*x268))+(((0.002)*x265))+(((-1.0)*pz*x267)))),IKFAST_ATAN2_MAGTHRESH);
if(!x274.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x273.value)))+(x274.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x275=IKcos(j1);
IkReal x276=IKsin(j1);
IkReal x277=(cj0*px);
IkReal x278=((0.002)*sj2);
IkReal x279=((0.2802)*cj2);
IkReal x280=(py*sj0);
IkReal x281=((0.002)*cj2);
IkReal x282=((0.2802)*sj2);
IkReal x283=((0.002)*x276);
IkReal x284=((1.0)*x275);
IkReal x285=((0.0600048)*x275);
IkReal x286=(pz*x276);
IkReal x287=(x276*x277);
evalcond[0]=((0.0300024)+(((-1.0)*x277*x284))+(((-1.0)*x280*x284))+x286+x282+x281);
evalcond[1]=((0.236815132767373)+x279+(((-1.0)*x287))+(((-1.0)*pz*x284))+(((-1.0)*x276*x280))+(((-1.0)*x278)));
evalcond[2]=(((x275*x278))+(((-0.236815132767373)*x275))+(((0.0300024)*x276))+pz+(((-1.0)*x275*x279))+((x276*x282))+((x276*x281)));
evalcond[3]=((((-1.0)*x277))+(((0.0300024)*x275))+(((-1.0)*x280))+((x275*x282))+((x275*x281))+((x276*x279))+(((0.236815132767373)*x276))+(((-1.0)*x276*x278)));
evalcond[4]=((0.0215344888866115)+(((0.473630265534746)*pz*x275))+(((-1.0)*(px*px)))+(((-0.0600048)*x286))+(((0.473630265534746)*x276*x280))+(((-1.0)*(pz*pz)))+(((0.473630265534746)*x287))+((x280*x285))+(((-1.0)*(py*py)))+((x277*x285)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x288=cj2*cj2;
IkReal x289=(cj2*sj2);
IkReal x290=(cj0*px);
IkReal x291=((0.2802)*cj2);
IkReal x292=(py*sj0);
IkReal x293=((0.002)*sj2);
IkReal x294=((1.0)*pz);
CheckValue<IkReal> x295=IKPowWithIntegerCheck(IKsign(((((-0.002)*cj2*pz))+((x290*x293))+(((-1.0)*x291*x292))+(((-1.0)*x290*x291))+(((-0.2802)*pz*sj2))+(((-0.0300024)*pz))+(((-0.236815132767373)*x290))+(((-0.236815132767373)*x292))+((x292*x293)))),-1);
if(!x295.valid){
continue;
}
CheckValue<IkReal> x296 = IKatan2WithCheck(IkReal(((-0.0560854071076285)+(((-0.07850804)*x288))+(((0.0011208)*x289))+(pz*pz)+(((0.000947260531069492)*sj2))+(((-0.132711200402836)*cj2)))),IkReal(((-0.00654462233933983)+(((-0.07850804)*x289))+(((-0.00888030274553475)*cj2))+(((-1.0)*x290*x294))+(((-0.0662955954014179)*sj2))+(((-0.0011208)*x288))+(((-1.0)*x292*x294)))),IKFAST_ATAN2_MAGTHRESH);
if(!x296.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x295.value)))+(x296.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x297=IKcos(j1);
IkReal x298=IKsin(j1);
IkReal x299=(cj0*px);
IkReal x300=((0.002)*sj2);
IkReal x301=((0.2802)*cj2);
IkReal x302=(py*sj0);
IkReal x303=((0.002)*cj2);
IkReal x304=((0.2802)*sj2);
IkReal x305=((0.002)*x298);
IkReal x306=((1.0)*x297);
IkReal x307=((0.0600048)*x297);
IkReal x308=(pz*x298);
IkReal x309=(x298*x299);
evalcond[0]=((0.0300024)+(((-1.0)*x302*x306))+x308+x304+x303+(((-1.0)*x299*x306)));
evalcond[1]=((0.236815132767373)+(((-1.0)*x309))+x301+(((-1.0)*x298*x302))+(((-1.0)*pz*x306))+(((-1.0)*x300)));
evalcond[2]=((((0.0300024)*x298))+(((-1.0)*x297*x301))+((x298*x303))+((x298*x304))+((x297*x300))+pz+(((-0.236815132767373)*x297)));
evalcond[3]=((((-1.0)*x299))+(((-1.0)*x298*x300))+(((0.0300024)*x297))+(((-1.0)*x302))+((x298*x301))+((x297*x304))+((x297*x303))+(((0.236815132767373)*x298)));
evalcond[4]=((0.0215344888866115)+(((-1.0)*(px*px)))+(((0.473630265534746)*x298*x302))+(((-0.0600048)*x308))+((x299*x307))+(((0.473630265534746)*x309))+(((0.473630265534746)*pz*x297))+(((-1.0)*(pz*pz)))+((x302*x307))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x310=cj2*cj2;
IkReal x311=(py*sj0);
IkReal x312=((0.002)*cj2);
IkReal x313=(cj2*sj2);
IkReal x314=(cj0*px);
IkReal x315=((0.2802)*sj2);
CheckValue<IkReal> x316 = IKatan2WithCheck(IkReal(((-0.00654462233933983)+(((-0.00888030274553475)*cj2))+(((-0.07850804)*x313))+(((-0.0662955954014179)*sj2))+((pz*x311))+((pz*x314))+(((-0.0011208)*x310)))),IkReal(((-0.07941218400576)+(((-0.0001200096)*cj2))+(((0.07850804)*x310))+(pz*pz)+(((-0.01681334496)*sj2))+(((-0.0011208)*x313)))),IKFAST_ATAN2_MAGTHRESH);
if(!x316.valid){
continue;
}
CheckValue<IkReal> x317=IKPowWithIntegerCheck(IKsign(((((-0.0300024)*x311))+(((-0.0300024)*x314))+(((-0.002)*pz*sj2))+(((-1.0)*x312*x314))+(((0.236815132767373)*pz))+(((0.2802)*cj2*pz))+(((-1.0)*x314*x315))+(((-1.0)*x311*x312))+(((-1.0)*x311*x315)))),-1);
if(!x317.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x316.value)+(((1.5707963267949)*(x317.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x318=IKcos(j1);
IkReal x319=IKsin(j1);
IkReal x320=(cj0*px);
IkReal x321=((0.002)*sj2);
IkReal x322=((0.2802)*cj2);
IkReal x323=(py*sj0);
IkReal x324=((0.002)*cj2);
IkReal x325=((0.2802)*sj2);
IkReal x326=((0.002)*x319);
IkReal x327=((1.0)*x318);
IkReal x328=((0.0600048)*x318);
IkReal x329=(pz*x319);
IkReal x330=(x319*x320);
evalcond[0]=((0.0300024)+(((-1.0)*x323*x327))+(((-1.0)*x320*x327))+x324+x325+x329);
evalcond[1]=((0.236815132767373)+(((-1.0)*x321))+x322+(((-1.0)*x330))+(((-1.0)*pz*x327))+(((-1.0)*x319*x323)));
evalcond[2]=(((x318*x321))+(((-0.236815132767373)*x318))+pz+(((-1.0)*x318*x322))+(((0.0300024)*x319))+((x319*x325))+((x319*x324)));
evalcond[3]=(((x318*x325))+((x318*x324))+(((-1.0)*x323))+(((-1.0)*x320))+(((-1.0)*x319*x321))+(((0.0300024)*x318))+((x319*x322))+(((0.236815132767373)*x319)));
evalcond[4]=((0.0215344888866115)+(((-1.0)*(px*px)))+((x323*x328))+((x320*x328))+(((0.473630265534746)*x319*x323))+(((0.473630265534746)*x330))+(((-1.0)*(pz*pz)))+(((0.473630265534746)*pz*x318))+(((-1.0)*(py*py)))+(((-0.0600048)*x329)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - roarm_m2 (b30d547a268f5ec047b96ce5e59c1e6c)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

